using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

[CustomEditor(typeof(PathDataSO))]
public class PathDataSOEditor : Editor
{
    private Direction newDirection;
    private bool showDirectionTools = true;
    
    public override void OnInspectorGUI()
    {
        PathDataSO pathData = (PathDataSO)target;
        
        // 绘制默认的Inspector
        DrawDefaultInspector();
        
        EditorGUILayout.Space(10);
        showDirectionTools = EditorGUILayout.Foldout(showDirectionTools, "方向序列工具", true);
        
        if (showDirectionTools)
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            
            // 显示当前方向序列
            EditorGUILayout.LabelField("当前方向序列", EditorStyles.boldLabel);
            EditorGUILayout.LabelField(pathData.GetDirectionSequenceString());
            
            EditorGUILayout.Space(5);
            
            // 添加方向按钮
            EditorGUILayout.BeginHorizontal();
            
            if (GUILayout.Button("↑", GUILayout.Width(40), GUILayout.Height(30)))
            {
                AddDirection(pathData, Direction.Up);
            }
            
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            
            if (GUILayout.Button("←", GUILayout.Width(40), GUILayout.Height(30)))
            {
                AddDirection(pathData, Direction.Left);
            }
            
            if (GUILayout.Button("↓", GUILayout.Width(40), GUILayout.Height(30)))
            {
                AddDirection(pathData, Direction.Down);
            }
            
            if (GUILayout.Button("→", GUILayout.Width(40), GUILayout.Height(30)))
            {
                AddDirection(pathData, Direction.Right);
            }
            
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.Space(5);
            
            // 删除最后一个方向
            if (GUILayout.Button("删除最后一个方向"))
            {
                if (pathData.directionSequence.Count > 0)
                {
                    pathData.directionSequence.RemoveAt(pathData.directionSequence.Count - 1);
                    EditorUtility.SetDirty(pathData);
                }
            }
            
            // 清空方向序列
            if (GUILayout.Button("清空方向序列"))
            {
                pathData.directionSequence.Clear();
                EditorUtility.SetDirty(pathData);
            }
            
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.Space(10);
            
            // 自动生成方向序列
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            EditorGUILayout.LabelField("自动生成方向序列", EditorStyles.boldLabel);
            
            if (GUILayout.Button("根据路径形状自动生成"))
            {
                AutoGenerateDirectionSequence(pathData);
            }
            
            EditorGUILayout.EndVertical();
        }
    }
    
    private void AddDirection(PathDataSO pathData, Direction direction)
    {
        pathData.directionSequence.Add(direction);
        EditorUtility.SetDirty(pathData);
    }
    
    private void AutoGenerateDirectionSequence(PathDataSO pathData)
    {
        // 清空现有序列
        pathData.directionSequence.Clear();
        
        // 确保路径点已生成
        pathData.GeneratePath();
        List<Vector2> points = pathData.GetPathPoints();
        
        if (points.Count < 3)
        {
            Debug.LogWarning("路径点太少，无法自动生成方向序列");
            return;
        }
        
        // 采样点（为了减少噪声，不使用所有点）
        int sampleCount = Mathf.Min(8, points.Count);
        List<Vector2> sampledPoints = new List<Vector2>();
        
        for (int i = 0; i < sampleCount; i++)
        {
            int index = (int)((float)i / (sampleCount - 1) * (points.Count - 1));
            sampledPoints.Add(points[index]);
        }
        
        // 分析主要方向
        for (int i = 1; i < sampledPoints.Count; i++)
        {
            Vector2 dir = sampledPoints[i] - sampledPoints[i - 1];
            
            // 忽略太短的段
            if (dir.magnitude < 0.1f) continue;
            
            // 确定主方向
            float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;
            
            // 将角度转换为方向
            Direction mainDir;
            
            if (angle >= -45 && angle < 45)
            {
                mainDir = Direction.Right;
            }
            else if (angle >= 45 && angle < 135)
            {
                mainDir = Direction.Up;
            }
            else if (angle >= -135 && angle < -45)
            {
                mainDir = Direction.Down;
            }
            else
            {
                mainDir = Direction.Left;
            }
            
            // 如果与上一个方向不同，则添加
            if (pathData.directionSequence.Count == 0 || pathData.directionSequence[pathData.directionSequence.Count - 1] != mainDir)
            {
                pathData.directionSequence.Add(mainDir);
            }
        }
        
        // 限制最大长度
        if (pathData.directionSequence.Count > 5)
        {
            pathData.directionSequence = pathData.directionSequence.GetRange(0, 5);
        }
        
        EditorUtility.SetDirty(pathData);
    }
} 